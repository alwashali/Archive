package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
)

func writelines(fileName string, dataset []string) {
	logsout, err := os.Create("fileName")
	if err != nil {
		fmt.Println(err)
	}
	defer logsout.Close()
	for _, l := range dataset {
		logsout.WriteString(l)
	}
}

func main() {

	prg := "/opt/zeek/bin/zeek"
	arg1 := "-Cr"
	pcapFolder := "./Malware-Traffic-Dataset/"

	var dataset []string
	pcaps, err := ioutil.ReadDir(pcapFolder)
	if err != nil {
		log.Fatal(err)
	}

	var header string

	// iterate over pcaps
	for _, f := range pcaps {
		if strings.Contains(f.Name(), "pcap") {
			arg2 := pcapFolder + f.Name()
			cmd := exec.Command(prg, arg1, arg2)
			fmt.Printf("Parsing %s\n", f.Name())
			err := cmd.Run()
			if err != nil {
				fmt.Println("Error executing command on", f.Name(), err.Error())
				return
			}
			//fmt.Println(prg, arg1, arg2)

			file, err := os.Open("conn.log")
			if err != nil {
				log.Println(err)
				continue
			}
			scanner := bufio.NewScanner(file) // f is the *os.File
			for scanner.Scan() {
				if strings.Contains(scanner.Text(), "#") {
					continue
				}
				dataset = append(dataset, scanner.Text())

			}
			if err := scanner.Err(); err != nil {
				fmt.Println("error reading line", err)
				fmt.Println("file:", f.Name())
			}

			e := os.Remove("conn.log")
			if e != nil {
				log.Fatal(e)
			}

		}

	}

}
